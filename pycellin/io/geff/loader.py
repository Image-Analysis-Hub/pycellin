#!/usr/bin/env python3

"""
loader.py

This module is part of the pycellin package.
It provides functionality to load a GEFF file into a pycellin model.

References:
- geff GitHub: https://github.com/live-image-tracking-tools/geff
- geff Documentation: https://live-image-tracking-tools.github.io/geff/latest/
"""

import importlib.metadata
import warnings
from datetime import datetime
from pathlib import Path
from typing import Any, Literal

import geff
import networkx as nx
from geff.metadata_schema import GeffMetadata

from pycellin.classes import CellLineage, Data, Model, Property, PropsMetadata
from pycellin.custom_types import PropertyType
from pycellin.graph.properties.core import (
    create_cell_coord_property,
    create_cell_id_property,
    create_frame_property,
    create_lineage_id_property,
)
from pycellin.io.utils import (
    _split_graph_into_lineages,
    _update_lineages_IDs_key,
    _update_node_prop_key,
    check_fusions,
)


def _recursive_dict_search(data: dict[str, Any], target_key: str) -> dict[str, Any] | None:
    """
    Recursively search for a target key in a nested dictionary structure.

    Parameters
    ----------
    data : dict
        The dictionary to search through.
    target_key : str
        The key to search for.

    Returns
    -------
    dict[str, Any] | None
        The dict associated with the target key if found, None otherwise.
    """
    if not isinstance(data, dict):
        return None
    if target_key in data:  # search in the current level
        return data[target_key]
    for value in data.values():  # recursive search in nested dictionaries
        if isinstance(value, dict):
            result = _recursive_dict_search(value, target_key)
            if result is not None:
                return result
    return None


def _has_node_prop_key(graph: nx.Graph, key: str) -> bool:
    """
    Check if all nodes in the graph have a specific property key.

    Parameters
    ----------
    graph : nx.Graph
        The graph to check.
    key : str
        The property key to look for.

    Returns
    -------
    bool
        True if all nodes have the property key, False otherwise.
    """
    return all(key in graph.nodes[node] for node in graph.nodes)


def _set_lineage_id(lineages: list[CellLineage]) -> None:
    """
    Set lineage IDs for the provided lineages.

    Parameters
    ----------
    lineages : list[CellLineage]
        List of CellLineage objects to set lineage IDs for.

    Warns
    -----
    UserWarning
        If no lineage identifier is found, a warning is issued and lineage IDs
        are autogenerated based on weakly connected components.
    """
    for lin_id, lin in enumerate(lineages):
        lin.graph["lineage_ID"] = lin_id
        for node in lin.nodes:
            lin.nodes[node]["lineage_ID"] = lin_id
    warnings.warn(
        "No lineage identifier found. Lineage IDs have been autogenerated.",
        stacklevel=3,
    )


def _identify_lin_id_key(
    lineage_id_key: str | None,
    geff_track_node_props: dict[Literal["lineage", "tracklet"], str] | None,
    geff_graph: nx.Graph,
) -> str | None:
    """
    Identify the lineage ID key from user input or geff metadata.

    If the lineage_id_key is provided by the user, the function will check
    that it exists in the graph. If not provided, the function will try to infer it
    from the geff track_node_props. If that fails, the function will create a new
    'lineage_ID' property.

    Parameters
    ----------
    lineage_id_key : str | None
        The key provided by the user to identify lineages.
    geff_track_node_props : dict[Literal["lineage", "tracklet"], str] | None
        The track_node_props from geff metadata.
    geff_graph : nx.Graph
        The geff graph.

    Returns
    -------
    str | None
        The identified lineage ID key, or None if not found or inferred.

    Warns
    -----
    UserWarning
        If the provided lineage_id_key is not found in the graph.
    """
    lin_id_key: str | None = None
    if lineage_id_key is not None:
        if _has_node_prop_key(geff_graph, lineage_id_key):
            lin_id_key = lineage_id_key
        else:
            warnings.warn(
                f"The provided lineage_id_key '{lineage_id_key}' is not found in the graph.",
                stacklevel=3,
            )
            lineage_id_key = None

    if lineage_id_key is None:
        if geff_track_node_props is not None:
            lin_id_key = geff_track_node_props.get("lineage")
        else:
            if _has_node_prop_key(geff_graph, "lineage_ID"):
                lin_id_key = "lineage_ID"
            else:
                lin_id_key = None

    return lin_id_key


def _identify_time_key(
    time_key: str | None,
    geff_display_hints: geff.metadata_schema.DisplayHint | None,
    geff_graph: nx.Graph,
) -> str:
    """
    Identify the time key from user input or geff metadata.

    If the time_key is provided by the user, the function will check
    that it exists in the graph. If not provided, it will try to infer it
    from the geff display hints or common conventions.

    Parameters
    ----------
    time_key : str | None
        The key provided by the user to identify time points.
    geff_display_hints : geff.metadata_schema.DisplayHint | None
        The display_hints from geff metadata.
    geff_graph : nx.Graph
        The geff graph.

    Returns
    -------
    str
        The identified time key.

    Raises
    ------
    ValueError
        If the provided time_key is not found in the graph.
    ValueError
        If no time key is found or inferred.
    NotImplementedError
        If the identified time key cannot be matched to 'frame'.
        Only 'frame' is currently supported.
    """
    # If I end up checking for a lot of keys, there are probably better ways to do it.
    # Use pattern matching?
    if time_key is not None:
        if not _has_node_prop_key(geff_graph, time_key):
            raise ValueError(f"The provided time_key '{time_key}' is not found in the graph.")
    else:
        if geff_display_hints is not None:
            time_key = getattr(geff_display_hints, "display_time", None)
        elif _has_node_prop_key(geff_graph, "frame"):
            time_key = "frame"
        # elif _has_node_prop_key(geff_graph, "t"):
        #     time_key = "t"
        # elif _has_node_prop_key(geff_graph, "time"):
        #     time_key = "time"
        elif _has_node_prop_key(geff_graph, "FRAME"):
            time_key = "FRAME"
        elif _has_node_prop_key(geff_graph, "Frame"):
            time_key = "Frame"

    if time_key is None:
        raise ValueError(
            "No time key found. Please provide a valid time_key argument or ensure "
            "that the geff file contains a time display hint."
        )

    # TODO: to update when pycellin can support any time key
    if time_key != "frame" and time_key.lower() == "frame":
        time_key = "frame"
    if time_key != "frame":
        raise NotImplementedError(
            f"Time key '{time_key}' cannot be matched to 'frame'. "
            "Pycellin currently only supports frame-like time keys."
        )

    return time_key


def _extract_space_key_from_display_hints(
    hint_field: str,
    geff_display_hints: geff.metadata_schema.DisplayHint | None,
    geff_graph: nx.Graph,
) -> str | None:
    """
    Extract a space key from geff display hints.

    Parameters
    ----------
    hint_field : str
        The field in the display hints to extract ('display_horizontal', 'display_vertical',
        or 'display_depth').
    geff_display_hints : geff.metadata_schema.DisplayHint | None
        The display_hints from geff metadata.
    geff_graph : nx.Graph
        The geff graph.

    Returns
    -------
    str | None
        The extracted space key, or None if not found.

    Warns
    -----
    UserWarning
        If the inferred space key is not found in the graph. In this case,
        the property is ignored.
    UserWarning
        If no display hint is found and no key is provided. In this case,
        the property is ignored.
    """
    mapping = {
        "display_horizontal": "x",
        "display_vertical": "y",
        "display_depth": "z",
    }

    if geff_display_hints is not None:
        space_key = getattr(geff_display_hints, hint_field, None)
        if space_key is not None and not _has_node_prop_key(geff_graph, space_key):
            warnings.warn(
                f"The inferred space key '{space_key}' is not found in the graph. "
                "Ignoring this property.",
                stacklevel=4,
            )
    else:
        space_key = None
        warnings.warn(
            f"No cell_{mapping[hint_field]}_key provided and no display hint found. "
            "Ignoring this property.",
            stacklevel=4,
        )

    return space_key


def _identify_space_keys(
    cell_x_key: str | None,
    cell_y_key: str | None,
    cell_z_key: str | None,
    geff_display_hints: geff.metadata_schema.DisplayHint | None,
    geff_graph: nx.Graph,
) -> tuple[str | None, str | None, str | None]:
    """
    Identify the space keys (x, y, z) from user input or geff metadata.

    If the space keys are provided by the user, the function will check
    that they exist in the graph. If not provided, it will try to infer them
    from the geff display hints.

    Parameters
    ----------
    cell_x_key : str | None
        The key provided by the user to identify the x-coordinate.
    cell_y_key : str | None
        The key provided by the user to identify the y-coordinate.
    cell_z_key : str | None
        The key provided by the user to identify the z-coordinate.
    geff_display_hints : geff.metadata_schema.DisplayHint | None
        The display_hints from geff metadata.
    geff_graph : nx.Graph
        The geff graph.

    Returns
    -------
    tuple[str | None, str | None, str | None]
        The identified space keys (cell_x_key, cell_y_key, cell_z_key).

    Warns
    -----
    UserWarning
        If any of the provided space keys are not found in the graph.
    """
    space_keys = [cell_x_key, cell_y_key, cell_z_key]

    # Validate provided keys and warn if they don't exist in the graph
    for dim, key in zip(["x", "y", "z"], space_keys):
        if key is not None:
            if not _has_node_prop_key(geff_graph, key):
                warnings.warn(
                    f"The provided cell_{dim}_key '{key}' is not found in the graph. "
                    "Ignoring this property.",
                    stacklevel=3,
                )

    # Update keys if they are None by extracting from display hints
    hint_fields = ["display_horizontal", "display_vertical", "display_depth"]
    for i, (hint_field, key) in enumerate(zip(hint_fields, space_keys)):
        if key is None:
            space_keys[i] = _extract_space_key_from_display_hints(
                hint_field, geff_display_hints, geff_graph
            )

    return space_keys[0], space_keys[1], space_keys[2]


def _extract_props_metadata(
    md: dict[str, geff.metadata_schema.PropMetadata],
    props_dict: dict[str, Property],
    prop_type: PropertyType,
    lin_type: str,
) -> None:
    """
    Extract properties metadata from a given dictionary and update the props_dict.

    Parameters
    ----------
    md : dict[str, geff.metadata_schema.PropMetadata]
        The dictionary containing properties metadata.
    props_dict : dict[str, Property]
        The dictionary to update with extracted properties metadata.
    prop_type : PropertyType
        The type of property being extracted ('node' or 'edge').

    Raises
    ------
    ValueError
        If an unsupported property type is provided.
    KeyError
        If a property identifier already exists in props_dict for the same property
        type.
    """
    for key, prop in md.items():
        if key not in props_dict:
            props_dict[key] = Property(
                identifier=key,
                name=prop.name or key,
                description=prop.description or prop.name or key,
                provenance="geff",
                prop_type=prop_type,
                lin_type=lin_type,
                dtype=prop.dtype,
                unit=prop.unit or None,
            )
        else:
            if props_dict[key].prop_type != prop_type:
                # The key must be unique but it already exists for nodes or edges,
                # so it needs to be renamed.
                if prop_type == "node":
                    current_prefix = "cell"
                    other_prefix = "link"
                elif prop_type == "edge":
                    current_prefix = "link"
                    other_prefix = "cell"
                else:
                    raise ValueError(
                        f"Unsupported property type: {prop_type}. Expected 'node' or 'edge'."
                    )
                # Rename the new property to be added.
                new_key = f"{current_prefix}_{key}"
                props_dict[new_key] = Property(
                    identifier=new_key,
                    name=prop.name or key,
                    description=prop.description or prop.name or key,
                    provenance="geff",
                    prop_type=prop_type,
                    lin_type=lin_type,
                    dtype=prop.dtype,
                    unit=prop.unit or None,
                )
                # Rename the other property as well for clarity.
                other_key = f"{other_prefix}_{key}"
                other_prop = props_dict.pop(key)
                other_prop.identifier = other_key
                props_dict[other_key] = other_prop
            else:
                # GEFF ensure uniqueness of property keys for nodes and edges separately,
                # so this should never happen.
                raise KeyError(
                    f"Property '{key}' already exists in props_dict for {prop_type}s. "
                    "Please ensure unique property identifiers."
                )


def _extract_lin_props_metadata(
    md: dict[str, Any],
    props_dict: dict[str, Property],
) -> None:
    """
    Extract lineage properties metadata from a given dictionary and update the props_dict.

    Parameters
    ----------
    md : dict[str, Any]
        The dictionary containing lineage properties metadata.
    props_dict : dict[str, Property]
        The dictionary to update with extracted lineage properties metadata.

    Raises
    ------
    KeyError
        If a property identifier already exists in props_dict for lineages.
    """
    for key, prop in md.items():
        if key not in props_dict:
            props_dict[key] = Property(
                identifier=key,
                name=prop.get("name") or key,
                description=prop.get("description") or prop.get("name") or key,
                provenance="geff",
                prop_type="lineage",
                lin_type="CellLineage",
                dtype=prop.get("dtype"),
                unit=prop.get("unit") or None,
            )
        else:
            if props_dict[key].prop_type != "lineage":
                # The key must be unique but it already exists for nodes or edges,
                # so it needs to be renamed.
                new_key = f"lin_{key}"
                props_dict[new_key] = Property(
                    identifier=new_key,
                    name=prop.get("name") or key,
                    description=prop.get("description") or prop.get("name") or key,
                    provenance="geff",
                    prop_type="lineage",
                    lin_type="CellLineage",
                    dtype=prop.get("dtype"),
                    unit=prop.get("unit") or None,
                )
            else:
                raise KeyError(
                    f"Property '{key}' already exists in props_dict for lineages. "
                    "Please ensure unique property identifiers."
                )


def _build_props_metadata(geff_md: geff.metadata_schema.GeffMetadata) -> dict[str, Property]:
    """
    Read and extract properties metadata from geff metadata.

    Parameters
    ----------
    geff_md : geff.metadata_schema.GeffMetadata
        The geff metadata object containing properties metadata.

    Returns
    -------
    dict[str, Property]
        Dictionary mapping property identifiers to Property objects.
    """
    props_dict: dict[str, Property] = {}
    if geff_md.node_props_metadata is not None:
        _extract_props_metadata(geff_md.node_props_metadata, props_dict, "node", "CellLineage")
    if geff_md.edge_props_metadata is not None:
        _extract_props_metadata(geff_md.edge_props_metadata, props_dict, "edge", "CellLineage")

    # TODO: for now lineage properties are not associated to a specific tag but stored
    # somewhere in the "extra" field. We need to check recursively if there is a dict
    # key called "lineage_props_metadata" in the "extra" field.
    # => No need for this anymore, thanks to geffception. Lineage properties are now
    # extracted directly from the lineage GEFF.
    # if geff_md.extra is not None:
    #     # Recursive search for the "lineage_props_metadata" key through the "extra"
    #     # field dict of dicts of dicts...
    #     lin_props_metadata = _recursive_dict_search(geff_md.extra, "lineage_props_metadata")
    #     if lin_props_metadata is not None:
    #         _extract_lin_props_metadata(lin_props_metadata, props_dict)

    return props_dict


def _update_props_metadata(
    metadata: dict[str, Property],
    geff_md: GeffMetadata,
    graph_level: Literal["tracklet", "lineage"],
) -> None:
    """
    Update properties metadata with additional geff metadata.

    This function extracts and merges properties metadata from tracklet or lineage
    geff metadata into the main properties metadata dictionary.

    Parameters
    ----------
    metadata : dict[str, Property]
        The main properties metadata dictionary to update.
    geff_md : GeffMetadata
        The GEFF metadata to use for updating.
    graph_level : Literal["tracklet", "lineage"]
        The graph level that defines the scope of the update ("tracklet" or "lineage").
    """
    if geff_md.node_props_metadata is not None:
        if graph_level == "tracklet":
            prop_type = "node"
            lin_type = "CycleLineage"
        elif graph_level == "lineage":
            prop_type = "lineage"
            lin_type = "CellLineage"
        _extract_props_metadata(
            md=geff_md.node_props_metadata,
            props_dict=metadata,
            prop_type=prop_type,
            lin_type=lin_type,
        )
    if geff_md.edge_props_metadata is not None:
        # We cannot have edge properties for lineages, so it must be tracklet.
        # TODO: Should I enforce this?
        _extract_props_metadata(
            md=geff_md.edge_props_metadata,
            props_dict=metadata,
            prop_type="edge",
            lin_type="CycleLineage",
        )


def _extract_units_from_axes(geff_md: GeffMetadata) -> dict[str, Any]:
    """
    Extract and validate space and time units from geff metadata axes.

    Parameters
    ----------
    geff_md : geff.metadata_schema.GeffMetadata
        The geff metadata object containing axes information.

    Returns
    -------
    dict[str, Any]
        Dictionary containing space_unit and time_unit keys.

    Raises
    ------
    ValueError
        If multiple space units or time units are found in axes.
    """
    units_metadata = {}

    if geff_md.axes is not None:
        # Check unicity of space time unit
        space_units = {
            axis.unit for axis in geff_md.axes if axis.type == "space" and axis.unit is not None
        }
        if len(space_units) > 1:
            raise ValueError(
                f"Multiple space units found in axes: {space_units}. "
                f"Pycellin assumes a single space unit."
            )
        units_metadata["space_unit"] = space_units.pop() if space_units else None

        # Check unicity of time unit
        time_units = {
            axis.unit for axis in geff_md.axes if axis.type == "time" and axis.unit is not None
        }
        if len(time_units) > 1:
            raise ValueError(
                f"Multiple time units found in axes: {time_units}. "
                f"Pycellin assumes a single time unit."
            )
        units_metadata["time_unit"] = time_units.pop() if time_units else None

    else:
        units_metadata["space_unit"] = None
        units_metadata["time_unit"] = None

    return units_metadata


def _extract_generic_metadata(
    geff_file: Path | str, geff_md: geff.metadata_schema.GeffMetadata
) -> dict[str, Any]:
    """
    Extract generic metadata for the model based on the geff file and its metadata.

    Parameters
    ----------
    geff_file : Path | str
        Path to the geff file.
    geff_md : geff.metadata_schema.GeffMetadata
        The geff metadata object.

    Returns
    -------
    dict[str, Any]
        Dictionary containing generic metadata.

    Raises
    ------
    importlib.metadata.PackageNotFoundError
        If the pycellin package is not found when trying to get its version.
    """
    metadata: dict[str, Any] = {}
    metadata["name"] = Path(geff_file).stem
    metadata["file_location"] = geff_file
    metadata["provenance"] = "geff"
    metadata["date"] = str(datetime.now())
    try:
        version = importlib.metadata.version("pycellin")
    except importlib.metadata.PackageNotFoundError:
        version = "unknown"
    metadata["pycellin_version"] = version
    metadata["geff_version"] = geff_md.geff_version
    if geff_md.extra is not None:
        metadata["geff_extra"] = geff_md.extra

    return metadata


def _build_generic_metadata(geff_file: Path | str, geff_md: GeffMetadata) -> dict[str, Any]:
    """
    Build and return a dictionary containing generic pycellin metadata.

    Parameters
    ----------
    geff_file : Path | str
        Path to the geff file.
    geff_md : geff.metadata_schema.GeffMetadata
        The geff metadata object to read from.

    Returns
    -------
    dict[str, Any]
        Dictionary containing generic pycellin metadata.
    """
    metadata = _extract_generic_metadata(geff_file, geff_md)
    units_metadata = _extract_units_from_axes(geff_md)
    metadata.update(units_metadata)

    return metadata


def _normalize_properties_data(
    lineages: list[CellLineage],
    lin_id_key: str,
    cell_x_key: str | None,
    cell_y_key: str | None,
    cell_z_key: str | None,
    time_key: str,
    cell_id_key: str | None,
) -> None:
    """
    Normalize properties data in lineages to match pycellin conventions.

    This function updates the property keys in lineage node data to use
    standardized pycellin naming conventions (e.g., 'cell_x', 'cell_y', 'frame').

    Parameters
    ----------
    lineages : list[CellLineage]
        List of CellLineage objects to normalize.
    lin_id_key : str
        The current lineage ID key name.
    cell_x_key : str | None
        The current x-coordinate key name, if any.
    cell_y_key : str | None
        The current y-coordinate key name, if any.
    cell_z_key : str | None
        The current z-coordinate key name, if any.
    time_key : str
        The current time key name.
    cell_id_key : str | None
        The current cell ID key name, if any.
    """
    if lin_id_key != "lineage_ID":
        _update_lineages_IDs_key(lineages, lin_id_key)
    for lin in lineages:
        if cell_x_key is not None and cell_x_key != "cell_x":
            _update_node_prop_key(lin, old_key=cell_x_key, new_key="cell_x")
        if cell_y_key is not None and cell_y_key != "cell_y":
            _update_node_prop_key(lin, old_key=cell_y_key, new_key="cell_y")
        if cell_z_key is not None and cell_z_key != "cell_z":
            _update_node_prop_key(lin, old_key=cell_z_key, new_key="cell_z")
        if time_key != "frame":
            _update_node_prop_key(lin, old_key=time_key, new_key="frame")
        if cell_id_key is None:
            for node in lin.nodes:
                lin.nodes[node]["cell_ID"] = node
        elif cell_id_key != "cell_ID":
            _update_node_prop_key(lin, old_key=cell_id_key, new_key="cell_ID")


def _normalize_properties_metadata(
    props_md: dict[str, Property],
    cell_x_key: str | None,
    cell_y_key: str | None,
    cell_z_key: str | None,
    space_unit: str | None,
) -> None:
    """
    Normalize properties metadata to match pycellin conventions.

    This function ensures that standard pycellin properties exist in the metadata
    and renames them to follow pycellin conventions.

    Parameters
    ----------
    props_md : dict[str, Property]
        The properties metadata dictionary to normalize.
    cell_x_key : str | None
        The current x-coordinate key name, if any.
    cell_y_key : str | None
        The current y-coordinate key name, if any.
    cell_z_key : str | None
        The current z-coordinate key name, if any.
    space_unit : str | None
        The space unit to use for coordinate properties.
    """
    # Ensure standard pycellin properties exist
    if "cell_ID" not in props_md:
        props_md["cell_ID"] = create_cell_id_property(provenance="geff")
    if "lineage_ID" not in props_md:
        props_md["lineage_ID"] = create_lineage_id_property(provenance="geff")
    if "frame" not in props_md:
        props_md["frame"] = create_frame_property(provenance="geff")

    # Create or normalize coordinate property keys
    for axis, geff_key in [
        ("x", cell_x_key),
        ("y", cell_y_key),
        ("z", cell_z_key),
    ]:
        pycellin_key = f"cell_{axis}"
        if geff_key is not None:
            if geff_key in props_md and geff_key != pycellin_key:
                props_md[pycellin_key] = props_md.pop(geff_key)
                props_md[pycellin_key].identifier = pycellin_key
            else:
                props_md[pycellin_key] = create_cell_coord_property(
                    unit=space_unit, axis=axis, provenance="geff"
                )


def load_GEFF(
    geff_file: Path | str,
    lineage_id_key: str | None = None,
    cell_id_key: str | None = None,
    cell_x_key: str | None = None,
    cell_y_key: str | None = None,
    cell_z_key: str | None = None,
    time_key: str | None = None,
    validate_geff: bool = True,
    load_tracklet_geff: bool = False,
    load_lineage_geff: bool = False,
) -> Model:
    """
    Load a geff file and return a pycellin model containing the data.

    Parameters
    ----------
    geff_file : Path | str
        Path to the geff file to load.
    lineage_id_key: str | None, optional
        The key used to identify lineages in the geff file. If None, the function
        will try to infer it from the geff metadata or autogenerate lineage IDs
        based on weakly connected components.
    cell_id_key : str | None, optional
        The key used to identify cells in the geff file. If None, the default
        key 'cell_ID' will be created and populated based on the node IDs.
    cell_x_key : str | None, optional
        The key used to identify the x-coordinate of cells in the geff file.
    cell_y_key : str | None, optional
        The key used to identify the y-coordinate of cells in the geff file.
    cell_z_key : str | None, optional
        The key used to identify the z-coordinate of cells in the geff file.
    time_key : str | None, optional
        The key used to identify the time point of cells in the geff file.
        If None, the function will try to infer it from the geff metadata.
    validate_geff : bool, optional
        Whether to validate the GEFF file against its schema, i.e. is the GEFF
        file well-formed and compliant with the GEFF specification. Default is True.
    load_tracklet_geff : bool, optional
        Whether to load the tracklet GEFF file if available. Default is False.
    load_lineage_geff : bool, optional
        Whether to load the lineage GEFF file if available. Default is False.

    Returns
    -------
    Model
        A pycellin model containing the data from the geff file.
    """
    # Read the GEFF file(s)
    geff_graph, geff_md = geff.read_nx(geff_file, validate=validate_geff)
    if not geff_md.directed:
        raise ValueError(
            "The geff graph is undirected: pycellin does not support undirected graphs."
        )
    if load_tracklet_geff:
        tracklet_geff = Path(geff_file, "tracklets.geff")
        if tracklet_geff.exists():
            print(f"Loading tracklet GEFF from {tracklet_geff}")
            tracklet_geff_graph, tracklet_geff_md = geff.read_nx(
                tracklet_geff, validate=validate_geff
            )
        else:
            # TODO: should this be a warning instead of an error?
            # So the main GEFF can still be loaded?
            raise FileNotFoundError(f"Tracklet GEFF file not found: {tracklet_geff}")
    if load_lineage_geff:
        lineage_geff = Path(geff_file, "lineages.geff")
        if lineage_geff.exists():
            print(f"Loading lineage GEFF from {lineage_geff}")
            lineage_geff_graph, lineage_geff_md = geff.read_nx(lineage_geff, validate=validate_geff)
        else:
            # TODO: should this be a warning instead of an error?
            # So the main GEFF can still be loaded?
            raise FileNotFoundError(f"Lineage GEFF file not found: {lineage_geff}")

    # Extract and dispatch metadata
    generic_md = _build_generic_metadata(geff_file, geff_md)
    props_md = _build_props_metadata(geff_md)
    if load_tracklet_geff:
        _update_props_metadata(metadata=props_md, geff_md=tracklet_geff_md, graph_level="tracklet")
    if load_lineage_geff:
        _update_props_metadata(metadata=props_md, geff_md=lineage_geff_md, graph_level="lineage")

    # Identify specific props keys
    lin_id_key = _identify_lin_id_key(lineage_id_key, geff_md.track_node_props, geff_graph)
    # print("lin_id_key:", lin_id_key)
    time_key = _identify_time_key(time_key, geff_md.display_hints, geff_graph)
    # print("time_key:", time_key)
    cell_x_key, cell_y_key, cell_z_key = _identify_space_keys(
        cell_x_key, cell_y_key, cell_z_key, geff_md.display_hints, geff_graph
    )
    # print("cell_x_key:", cell_x_key)
    # print("cell_y_key:", cell_y_key)
    # print("cell_z_key:", cell_z_key)

    # Split the graph into lineages
    # TODO: what if there are no lin_id_key? It is dealt with below but there is also
    # a case where _split_graph_into_lineages creates the lineage_ID itself
    lineages = _split_graph_into_lineages(geff_graph, lineage_ID_key=lin_id_key)
    # print(f"Number of lineages: {len(lineages)}")
    if lin_id_key is None:
        _set_lineage_id(lineages)
        lin_id_key = "lineage_ID"

    # Integrate the lineage properties from the lineage GEFF into the pycellin model
    # TODO: this is wonky. We can generate lineage IDs based on the node IDs of
    # the lineage GEFF but then the lineage IDs won't match the ones in the main GEFF.
    # And if no lineage_IDs in any of the GEFFs, there is no way to match them.
    # Wait for geffception and see if the presence of lineage IDs is enforced.
    # TODO: apparently I have cell props on lineage GEFF nodes...?!
    if load_lineage_geff:
        if len(lineage_geff_graph) != len(lineages):
            warnings.warn(
                f"Inconsistency between the number of lineages in the main GEFF ({len(lineages)}) "
                f"and in the lineage GEFF ({len(lineage_geff_graph)})."
                "Some lineages might not be updated with their lineage properties.",
                stacklevel=2,
            )
        for lin_node, lin_data in lineage_geff_graph.nodes(data=True):
            print(lin_data)
            lin_id = lin_data.get("lineage_ID")
            if lin_id is None:
                continue
            try:
                lin = next(l for l in lineages if l.graph["lineage_ID"] == lin_id)
            except StopIteration:
                warnings.warn(
                    f"Lineage with lineage_ID '{lin_id}' found in the lineage GEFF "
                    "but not in the main GEFF. Skipping.",
                    stacklevel=2,
                )
                continue
            for prop_key, prop_value in lin_data.items():
                if prop_key != "lineage_ID":
                    lin.graph[prop_key] = prop_value

    # Rename properties to match pycellin conventions
    _normalize_properties_data(
        lineages, lin_id_key, cell_x_key, cell_y_key, cell_z_key, time_key, cell_id_key
    )
    _normalize_properties_metadata(
        props_md, cell_x_key, cell_y_key, cell_z_key, generic_md["space_unit"]
    )

    # Create the model
    model = Model(
        model_metadata=generic_md,
        props_metadata=PropsMetadata(props=props_md),
        data=Data({lin.graph["lineage_ID"]: lin for lin in lineages}),
    )
    check_fusions(model)  # pycellin DOES NOT support fusion events

    return model


if __name__ == "__main__":
    geff_file = "/media/lxenard/data/Janelia_Cell_Trackathon/reader_test_graph.geff"
    geff_file = "E:/Janelia_Cell_Trackathon/reader_test_graph.geff"
    geff_file = "E:/Janelia_Cell_Trackathon/test_geffception/FakeTracks.geff"
    geff_file = "/media/lxenard/data/Janelia_Cell_Trackathon/test_geffception/FakeTracks.geff"
    # geff_file = "/media/lxenard/data/Janelia_Cell_Trackathon/mouse-20250719.zarr/tracks"
    # geff_file = "/media/lxenard/data/Janelia_Cell_Trackathon/test_pycellin_geff/test.zarr"
    # geff_file = (
    #     "/media/lxenard/data/Janelia_Cell_Trackathon/test_pycellin_geff/pycellin_to_geff.geff"
    # )
    # geff_file = "E:/Janelia_Cell_Trackathon/test_pycellin_geff/pycellin_to_geff.geff"
    # geff_file = "/media/lxenard/data/Janelia_Cell_Trackathon/test_trackmate_to_geff/FakeTracks.geff"
    # geff_file = "E:/Janelia_Cell_Trackathon/test_trackmate_to_geff/FakeTracks.geff"

    # Yohsuke's file for geffception
    # geff_file = "/media/lxenard/data/Janelia_Cell_Trackathon/cell_segmentation.zarr/tree.geff"
    # geff_file = "E:/Janelia_Cell_Trackathon/cell_segmentation.zarr/tree.geff"
    # geff_file = "/media/lxenard/data/Janelia_Cell_Trackathon/cell_segmentation.zarr/tree.geff/linage_tree.geff"
    # geff_file = "E:/Janelia_Cell_Trackathon/cell_segmentation.zarr/tree.geff/linage_tree.geff"

    import plotly.io as pio

    # Plotly: set the default renderer to browser so I can visualize plots
    pio.renderers.default = "browser"

    print(geff_file)
    model = load_GEFF(
        geff_file,
        validate_geff=True,
        load_tracklet_geff=True,
        load_lineage_geff=True,
        # cell_x_key="x",
        # cell_y_key="y",
    )
    # print(model)
    for prop_key, prop in model.props_metadata.props.items():
        print(f"{prop_key}: {prop.prop_type}, {prop.lin_type}")
    # print("props_dict", model.props_metadata.props)
    # for k in model.props_metadata.props.keys():
    #     print(f"{k}")
    lineages = model.get_cell_lineages()
    # print(f"Number of lineages: {len(lineages)}")
    # for lin in lineages:
    #     print(lin)
    lin0 = lineages[0]
    print(lin0.graph)
    # lin7 = model.get_cell_lineage_from_ID(7)
    # lin7.plot(
    #     node_hover_props=[
    #         "cell_ID",
    #         "lineage_ID",
    #         "frame",
    #         "cell_x",
    #         "cell_y",
    #         "track_id",
    #         "seg_id",
    #         "tree_id",
    #     ]
    # )
    # print(lin0.nodes(data=True))
    # for node in lin0.nodes(data=True):
    #     print(node)
    #     break
    # lin0.plot()

    # cell_id_key
    # lineage_id_key
    # time_key
    # cell_x_key
    # cell_y_key
    # cell_z_key

    # geff_graph, geff_md = geff.read_nx(geff_file, validate=True)
    # print(geff_graph)
    # # Check how many weakly connected components there are.
    # print(
    #     f"Number of weakly connected components: {len(list(nx.weakly_connected_components(geff_graph)))}"
    # )
    # for k, v in geff_graph.graph.items():
    #     print(f"{k}: {v}")
    # # print(graph.graph["axes"][0].unit)

    # if geff_md.directed:
    #     print("The graph is directed.")

    # metadata = {}  # type: dict[str, Any]
    # metadata["name"] = Path(geff_file).stem
    # metadata["file_location"] = geff_file
    # metadata["provenance"] = "geff"
    # metadata["date"] = str(datetime.now())
    # # metadata["space_unit"] =
    # # metadata["time_unit"] =
    # metadata["pycellin_version"] = version("pycellin")
    # metadata["geff_version"] = geff_md.geff_version
    # for md in geff_md:
    #     print(md)
