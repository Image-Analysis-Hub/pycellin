#!/usr/bin/env python3

"""
loader.py

This module is part of the pycellin package.
It provides functionality to load a GEFF file into a pycellin model.

References:
- geff GitHub: https://github.com/live-image-tracking-tools/geff
- geff Documentation: https://live-image-tracking-tools.github.io/geff/latest/
"""

import importlib.metadata
import warnings
from datetime import datetime
from pathlib import Path
from typing import Any, Literal

import geff
import geff_spec
import networkx as nx

from pycellin.classes import CellLineage, Data, Model, Property, PropsMetadata
from pycellin.custom_types import PropertyType
from pycellin.graph.properties.core import (
    create_cell_coord_property,
    create_cell_id_property,
    create_frame_property,
    create_lineage_id_property,
)
from pycellin.io.utils import (
    _graph_has_node_prop,
    _split_graph_into_lineages,
    _update_lineages_IDs_key,
    _update_node_prop_key,
    check_fusions,
)


def _recursive_dict_search(
    data: dict[str, Any], target_key: str
) -> dict[str, Any] | None:
    """
    Recursively search for a target key in a nested dictionary structure.

    Parameters
    ----------
    data : dict
        The dictionary to search through.
    target_key : str
        The key to search for.

    Returns
    -------
    dict[str, Any] | None
        The dict associated with the target key if found, None otherwise.
    """
    if not isinstance(data, dict):
        return None
    if target_key in data:  # search in the current level
        return data[target_key]
    for value in data.values():  # recursive search in nested dictionaries
        if isinstance(value, dict):
            result = _recursive_dict_search(value, target_key)
            if result is not None:
                return result
    return None


def _set_lineage_id(lineages: list[CellLineage]) -> None:
    """
    Set lineage IDs for the provided lineages.

    Parameters
    ----------
    lineages : list[CellLineage]
        List of CellLineage objects to set lineage IDs for.

    Warns
    -----
    UserWarning
        If no lineage identifier is found, a warning is issued and lineage IDs
        are autogenerated based on weakly connected components.
    """
    for lin_id, lin in enumerate(lineages):
        lin.graph["lineage_ID"] = lin_id
        for node in lin.nodes:
            lin.nodes[node]["lineage_ID"] = lin_id
    warnings.warn(
        "No lineage identifier found. Lineage IDs have been autogenerated.",
        stacklevel=3,
    )


def _identify_lin_id_prop(
    lin_id_prop: str | None,
    geff_track_node_props: dict[Literal["lineage", "tracklet"], str] | None,
    geff_graph: nx.Graph,
) -> str | None:
    """
    Identify the lineage ID key from user input or GEFF metadata.

    If lin_id_prop is provided, the function will check that the property exists
    in all nodes of the graph. If not provided, the function will try to infer it
    from the GEFF track_node_props. If that fails, the function will create a new
    'lineage_ID' property.

    Parameters
    ----------
    lin_id_prop : str | None
        Name of the property to identify lineages.
    geff_track_node_props : dict[Literal["lineage", "tracklet"], str] | None
        The track_node_props from GEFF metadata.
    geff_graph : nx.Graph
        The GEFF graph.

    Returns
    -------
    str | None
        The identified lineage ID key, or None if not found or inferred.

    Warns
    -----
    UserWarning
        If the provided lin_id_prop is not found in the GEFF graph.
    """
    error_stack_level = 3

    lin_id_key: str | None = None
    if lin_id_prop is not None:
        if _graph_has_node_prop(geff_graph, lin_id_prop):
            lin_id_key = lin_id_prop
        else:
            warnings.warn(
                f"The provided property '{lin_id_prop}' is not present in the graph. "
                "Lineage identifier will be infered from GEFF metadata.",
                stacklevel=error_stack_level,
            )
            lin_id_prop = None

    if lin_id_prop is None:
        if geff_track_node_props is not None:
            lin_id_key = geff_track_node_props.get("lineage")
        else:
            if _graph_has_node_prop(geff_graph, "lineage_ID"):
                lin_id_key = "lineage_ID"
            else:
                warnings.warn(
                    "No lineage identifier found in GEFF metadata. "
                    "Lineage IDs will be autogenerated.",
                    stacklevel=error_stack_level,
                )
                lin_id_key = None

    return lin_id_key


def _identify_time_prop(
    time_key: str | None,
    geff_md: geff.GeffMetadata | None,
    geff_graph: nx.Graph,
) -> str:
    """
    Identify the time property from argument or GEFF metadata.

    If a time key is provided, the function will check that it exists in the graph.
    If not provided, the function will try to infer it from the GEFF metadata,
    first from the display hints, then from the axes.
    In case the function fallbacks to the GEFF axes, it will take time axes in order
    and check if the corresponding key exists in the graph. The first one to be found
    will be returned as the time property.

    Parameters
    ----------
    time_key : str | None
        The key provided to identify time points.
    geff_md : geff.GeffMetadata | None
        The GEFF metadata.
    geff_graph : nx.Graph
        The GEFF graph.

    Returns
    -------
    str
        The identified time property.

    Raises
    ------
    ValueError
        If no time property is found or inferred.

    Warns
    -----
    UserWarning
        If the provided time_key is not present in the graph, triggering fallback
        inference from GEFF metadata.
    UserWarning
        If a valid time property is inferred from display hints.
    UserWarning
        If a valid time property is inferred from axes.
    """
    if time_key is not None:
        if not _graph_has_node_prop(geff_graph, time_key):
            warnings.warn(
                f"The provided property '{time_key}' is not present in the graph. "
                "It will be inferred from GEFF metadata, if possible.",
                stacklevel=3,
            )
            time_key = None

    # Fallback to GEFF display hints.
    hints = geff_md.display_hints if geff_md is not None else None
    if time_key is None and hints is not None:
        time_key = getattr(hints, "display_time", None)
        if time_key is not None:
            if _graph_has_node_prop(geff_graph, time_key):
                warnings.warn(
                    f"Valid time property inferred from display hints: '{time_key}'.",
                    stacklevel=3,
                )
            else:
                time_key = None

    # Fallback to GEFF axes.
    axes = geff_md.axes if geff_md is not None else None
    if time_key is None and axes is not None:
        time_axes = [axis for axis in axes if axis.type == "time"]
        for axis in time_axes:
            if axis.name is not None and _graph_has_node_prop(geff_graph, axis.name):
                time_key = axis.name
                warnings.warn(
                    f"Valid time property inferred from axes: '{time_key}'.",
                    stacklevel=3,
                )
                break

    if time_key is None:
        raise ValueError(
            "No valid time property found. Please provide a valid property argument "
            "or ensure that the GEFF file contains a time axis or a time display hint."
        )

    return time_key


def _identify_space_props(
    cell_x_key: str | None,
    cell_y_key: str | None,
    cell_z_key: str | None,
    geff_md: geff.GeffMetadata | None,
    geff_graph: nx.Graph,
) -> tuple[str | None, str | None, str | None]:
    """
    Identify the space properties (x, y, z) from arguments or GEFF metadata.

    If space keys are provided, the function will check that they exist in the graph.
    If not provided, the function will try to infer them from the GEFF metadata,
    first from the display hints, then from the axes.

    Parameters
    ----------
    cell_x_key : str | None
        The key provided by the user to identify the x-coordinate.
    cell_y_key : str | None
        The key provided by the user to identify the y-coordinate.
    cell_z_key : str | None
        The key provided by the user to identify the z-coordinate.
    geff_md : geff.GeffMetadata | None
        The metadata from GEFF file.
    geff_graph : nx.Graph
        The geff graph.

    Returns
    -------
    tuple[str | None, str | None, str | None]
        The identified space properties.

    Warns
    -----
    UserWarning
        If any of the provided space properties are not found in the graph.
    """
    space_keys = [cell_x_key, cell_y_key, cell_z_key]
    for i, key in enumerate(space_keys):
        if key is not None:
            if not _graph_has_node_prop(geff_graph, key):
                warnings.warn(
                    f"The provided property '{key}' is not present in the graph. "
                    "It will be inferred from GEFF metadata, if possible.",
                    stacklevel=3,
                )
                space_keys[i] = None

    # Fallback to GEFF display hints.
    hints = geff_md.display_hints if geff_md is not None else None
    hint_fields = ["display_horizontal", "display_vertical", "display_depth"]
    for i, (hint_field, key) in enumerate(zip(hint_fields, space_keys)):
        if key is None and hints is not None:
            space_key = getattr(hints, hint_field, None)
            if space_key is not None:
                if _graph_has_node_prop(geff_graph, space_key):
                    warnings.warn(
                        f"Valid space property inferred from display hints: '{space_key}'.",
                        stacklevel=3,
                    )
                else:
                    space_key = None
            space_keys[i] = space_key

    # Fallback to GEFF axes: space axes are consumed in order.
    axes = geff_md.axes if geff_md is not None else None
    if axes is not None:
        space_axes = iter(axis for axis in axes if axis.type == "space")
        for i, key in enumerate(space_keys):
            if key is None:
                for axis in space_axes:
                    if axis.name is not None and _graph_has_node_prop(
                        geff_graph, axis.name
                    ):
                        space_keys[i] = axis.name
                        warnings.warn(
                            f"Valid space property inferred from axes: '{space_keys[i]}'.",
                            stacklevel=3,
                        )
                        break

    return space_keys[0], space_keys[1], space_keys[2]


def _extract_props_metadata(
    md: dict[str, geff_spec.PropMetadata],
    props_dict: dict[str, Property],
    prop_type: PropertyType,
) -> None:
    """
    Extract properties metadata from a given dictionary and update the props_dict.

    Parameters
    ----------
    md : dict[str, geff_spec.PropMetadata]
        The dictionary containing properties metadata.
    props_dict : dict[str, Property]
        The dictionary to update with extracted properties metadata.
    prop_type : PropertyType
        The type of property being extracted ('node' or 'edge').

    Raises
    ------
    ValueError
        If an unsupported property type is provided.
    KeyError
        If a property identifier already exists in props_dict for the same property
        type.
    """
    for key, prop in md.items():
        if key not in props_dict:
            props_dict[key] = Property(
                identifier=key,
                name=prop.name or key,
                description=prop.description or prop.name or key,
                provenance="geff",
                prop_type=prop_type,
                lin_type="CellLineage",
                dtype=prop.dtype,
                unit=prop.unit or None,
            )
        else:
            if props_dict[key].prop_type != prop_type:
                # The key must be unique but it already exists for nodes or edges,
                # so it needs to be renamed.
                if prop_type == "node":
                    current_prefix = "cell"
                    other_prefix = "link"
                elif prop_type == "edge":
                    current_prefix = "link"
                    other_prefix = "cell"
                else:
                    raise ValueError(
                        f"Unsupported property type: {prop_type}. Expected 'node' or 'edge'."
                    )
                # Rename the new property to be added.
                new_key = f"{current_prefix}_{key}"
                props_dict[new_key] = Property(
                    identifier=new_key,
                    name=prop.name or key,
                    description=prop.description or prop.name or key,
                    provenance="geff",
                    prop_type=prop_type,
                    lin_type="CellLineage",
                    dtype=prop.dtype,
                    unit=prop.unit or None,
                )
                # Rename the other property as well for clarity.
                other_key = f"{other_prefix}_{key}"
                other_prop = props_dict.pop(key)
                other_prop.identifier = other_key
                props_dict[other_key] = other_prop
            else:
                # GEFF ensure uniqueness of property keys for nodes and edges separately,
                # so this should never happen.
                raise KeyError(
                    f"Property '{key}' already exists in props_dict for {prop_type}s. "
                    "Please ensure unique property identifiers."
                )


def _extract_lin_props_metadata(
    md: dict[str, Any],
    props_dict: dict[str, Property],
) -> None:
    """
    Extract lineage properties metadata from a given dictionary and update the props_dict.

    Parameters
    ----------
    md : dict[str, Any]
        The dictionary containing lineage properties metadata.
    props_dict : dict[str, Property]
        The dictionary to update with extracted lineage properties metadata.

    Raises
    ------
    KeyError
        If a property identifier already exists in props_dict for lineages.
    """
    for key, prop in md.items():
        if key not in props_dict:
            props_dict[key] = Property(
                identifier=key,
                name=prop.get("name") or key,
                description=prop.get("description") or prop.get("name") or key,
                provenance="geff",
                prop_type="lineage",
                lin_type="CellLineage",
                dtype=prop.get("dtype"),
                unit=prop.get("unit") or None,
            )
        else:
            if props_dict[key].prop_type != "lineage":
                # The key must be unique but it already exists for nodes or edges,
                # so it needs to be renamed.
                new_key = f"lin_{key}"
                props_dict[new_key] = Property(
                    identifier=new_key,
                    name=prop.get("name") or key,
                    description=prop.get("description") or prop.get("name") or key,
                    provenance="geff",
                    prop_type="lineage",
                    lin_type="CellLineage",
                    dtype=prop.get("dtype"),
                    unit=prop.get("unit") or None,
                )
            else:
                raise KeyError(
                    f"Property '{key}' already exists in props_dict for lineages. "
                    "Please ensure unique property identifiers."
                )


def _build_props_metadata(geff_md: geff.GeffMetadata) -> dict[str, Property]:
    """
    Read and extract properties metadata from geff metadata.

    Parameters
    ----------
    geff_md : geff.GeffMetadata
        The geff metadata object containing properties metadata.

    Returns
    -------
    dict[str, Property]
        Dictionary mapping property identifiers to Property objects.
    """
    props_dict: dict[str, Property] = {}
    if geff_md.node_props_metadata is not None:
        _extract_props_metadata(geff_md.node_props_metadata, props_dict, "node")
    if geff_md.edge_props_metadata is not None:
        _extract_props_metadata(geff_md.edge_props_metadata, props_dict, "edge")

    # TODO: for now lineage properties are not associated to a specific tag but stored
    # somewhere in the "extra" field. We need to check recursively if there is a dict
    # key called "lineage_props_metadata" in the "extra" field.
    # For now I keep this, but it should be replaced by geffception at some point.
    if geff_md.extra is not None:
        # Recursive search for the "lineage_props_metadata" key through the "extra"
        # field dict of dicts of dicts...
        lin_props_metadata = _recursive_dict_search(
            geff_md.extra, "lineage_props_metadata"
        )
        if lin_props_metadata is not None:
            _extract_lin_props_metadata(lin_props_metadata, props_dict)

    return props_dict


def _extract_units_from_axes(geff_md: geff.GeffMetadata) -> dict[str, Any]:
    """
    Extract and validate space and time units from GEFF metadata axes.

    Parameters
    ----------
    geff_md : geff.GeffMetadata
        The geff metadata object containing axes information.

    Returns
    -------
    dict[str, Any]
        Dictionary containing space_unit and time_unit keys.

    Raises
    ------
    ValueError
        If multiple space units or time units are found in axes.
    """
    units_metadata = {}
    # TODO:
    # - raise a warning instead of an error
    # - don't store this as units of the model unless we are sure that the user
    # actually wants these properties as reference space and time properties.

    if geff_md.axes is not None:
        # Check unicity of space time unit
        space_units = {
            axis.unit
            for axis in geff_md.axes
            if axis.type == "space" and axis.unit is not None
        }
        if len(space_units) > 1:
            raise ValueError(
                f"Multiple space units found in axes: {space_units}. "
                f"Pycellin assumes a single space unit."
            )
        units_metadata["space_unit"] = space_units.pop() if space_units else None

        # Check unicity of time unit
        time_units = {
            axis.unit
            for axis in geff_md.axes
            if axis.type == "time" and axis.unit is not None
        }
        if len(time_units) > 1:
            raise ValueError(
                f"Multiple time units found in axes: {time_units}. "
                f"Pycellin assumes a single time unit."
            )
        units_metadata["time_unit"] = time_units.pop() if time_units else None

    else:
        units_metadata["space_unit"] = None
        units_metadata["time_unit"] = None

    return units_metadata


def _extract_generic_metadata(
    geff_file: Path | str, geff_md: geff.GeffMetadata
) -> dict[str, Any]:
    """
    Extract generic metadata for the model based on the GEFF file and its metadata.

    Parameters
    ----------
    geff_file : Path | str
        Path to the GEFF file.
    geff_md : geff.GeffMetadata
        The geff metadata object.

    Returns
    -------
    dict[str, Any]
        Dictionary containing generic metadata.

    Raises
    ------
    importlib.metadata.PackageNotFoundError
        If the pycellin package is not found when trying to get its version.
    """
    metadata: dict[str, Any] = {}
    metadata["name"] = Path(geff_file).stem
    metadata["file_location"] = geff_file
    metadata["provenance"] = "geff"
    metadata["date"] = str(datetime.now())
    try:
        version = importlib.metadata.version("pycellin")
    except importlib.metadata.PackageNotFoundError:
        version = "unknown"
    metadata["pycellin_version"] = version
    metadata["geff_version"] = geff_md.geff_version
    if geff_md.extra is not None:
        metadata["geff_extra"] = geff_md.extra

    return metadata


def _build_generic_metadata(
    geff_file: Path | str, geff_md: geff.GeffMetadata, time_prop: str
) -> dict[str, Any]:
    """
    Build and return a dictionary containing pycellin generic metadata.

    Parameters
    ----------
    geff_file : Path | str
        Path to the geff file.
    geff_md : geff.GeffMetadata
        The geff metadata object to read from.
    time_prop : str
        The identified time property for the model.

    Returns
    -------
    dict[str, Any]
        Dictionary containing generic pycellin metadata.
    """
    metadata = _extract_generic_metadata(geff_file, geff_md)
    units_metadata = _extract_units_from_axes(geff_md)
    metadata.update(units_metadata)
    metadata["reference_time_property"] = time_prop

    return metadata


def _normalize_properties_data(
    lineages: list[CellLineage],
    lin_id_key: str,
    cell_x_key: str | None,
    cell_y_key: str | None,
    cell_z_key: str | None,
    time_key: str,
    cell_id_key: str | None,
) -> None:
    """
    Normalize properties data in lineages to match pycellin conventions.

    This function updates the property keys in lineage node data to use
    standardized pycellin naming conventions (e.g., 'cell_x', 'cell_y', 'frame').

    Parameters
    ----------
    lineages : list[CellLineage]
        List of CellLineage objects to normalize.
    lin_id_key : str
        The current lineage ID key name.
    cell_x_key : str | None
        The current x-coordinate key name, if any.
    cell_y_key : str | None
        The current y-coordinate key name, if any.
    cell_z_key : str | None
        The current z-coordinate key name, if any.
    cell_id_key : str | None
        The current cell ID key name, if any.
    """
    if lin_id_key != "lineage_ID":
        _update_lineages_IDs_key(lineages, lin_id_key)
    for lin in lineages:
        if cell_x_key is not None and cell_x_key != "cell_x":
            _update_node_prop_key(lin, old_key=cell_x_key, new_key="cell_x")
        if cell_y_key is not None and cell_y_key != "cell_y":
            _update_node_prop_key(lin, old_key=cell_y_key, new_key="cell_y")
        if cell_z_key is not None and cell_z_key != "cell_z":
            _update_node_prop_key(lin, old_key=cell_z_key, new_key="cell_z")
        if cell_id_key is None:
            for node in lin.nodes:
                lin.nodes[node]["cell_ID"] = node
        elif cell_id_key != "cell_ID":
            _update_node_prop_key(lin, old_key=cell_id_key, new_key="cell_ID")


def _normalize_properties_metadata(
    props_md: dict[str, Property],
    cell_x_key: str | None,
    cell_y_key: str | None,
    cell_z_key: str | None,
    space_unit: str | None,
) -> None:
    """
    Normalize properties metadata to match pycellin conventions.

    This function ensures that standard pycellin properties exist in the metadata
    and renames them to follow pycellin conventions.

    Parameters
    ----------
    props_md : dict[str, Property]
        The properties metadata dictionary to normalize.
    cell_x_key : str | None
        The current x-coordinate key name, if any.
    cell_y_key : str | None
        The current y-coordinate key name, if any.
    cell_z_key : str | None
        The current z-coordinate key name, if any.
    space_unit : str | None
        The space unit to use for coordinate properties.
    """
    # Ensure standard pycellin properties exist
    if "cell_ID" not in props_md:
        props_md["cell_ID"] = create_cell_id_property(provenance="geff")
    if "lineage_ID" not in props_md:
        props_md["lineage_ID"] = create_lineage_id_property(provenance="geff")
    if "frame" not in props_md:
        props_md["frame"] = create_frame_property(provenance="geff")

    # Create or normalize coordinate property keys
    for axis, geff_key in [
        ("x", cell_x_key),
        ("y", cell_y_key),
        ("z", cell_z_key),
    ]:
        pycellin_key = f"cell_{axis}"
        if geff_key is not None:
            if geff_key in props_md and geff_key != pycellin_key:
                props_md[pycellin_key] = props_md.pop(geff_key)
                props_md[pycellin_key].identifier = pycellin_key
            else:
                props_md[pycellin_key] = create_cell_coord_property(
                    unit=space_unit, axis=axis, provenance="geff"
                )


def load_GEFF(
    geff_file: Path | str,
    lineage_id_prop: str | None = None,
    cell_id_prop: str | None = None,
    cell_x_prop: str | None = None,
    cell_y_prop: str | None = None,
    cell_z_prop: str | None = None,
    time_prop: str | None = None,
    structure_validation: bool = True,
) -> Model:
    """
    Load a GEFF file and return a pycellin model containing the data and metadata.

    Parameters
    ----------
    geff_file : Path | str
        Path to the GEFF file to load.
    lineage_id_prop: str | None, optional
        Name of the property that identifies lineages in the GEFF file.
        If None, the function will try to infer it from the GEFF metadata
        or autogenerate it based on weakly connected components.
    cell_id_prop : str | None, optional
        Name of the property that identifies cells in the GEFF file.
        If None, the default property 'cell_ID' will be created and populated based
        on the node IDs.
    cell_x_prop : str | None, optional
        Name of the property that identifies the x-coordinate of cells in the GEFF file.
    cell_y_prop : str | None, optional
        Name of the property that identifies the y-coordinate of cells in the GEFF file.
    cell_z_prop : str | None, optional
        Name of the property that identifies the z-coordinate of cells in the GEFF file.
    time_prop : str | None, optional
        Name of the property to use as the reference time property.
        If None, it will be infered from the GEFF metadata.
    structure_validation : bool, optional
        Whether to validate the GEFF file's structure, i.e. to check that it is
        compliant with the GEFF specification. Default is True.

    Returns
    -------
    Model
        A pycellin model containing the data and metadata from the GEFF file.

    Raises
    ------
    ValueError
        If the GEFF graph is undirected, as pycellin does not support undirected graphs.
    """

    # Read the GEFF file.
    geff_graph, geff_md = geff.read(geff_file, structure_validation=structure_validation)
    if not geff_md.directed:
        raise ValueError(
            "The GEFF graph is undirected: pycellin does not support undirected graphs."
        )

    # Identify specific properties.
    lineage_id_prop = _identify_lin_id_prop(
        lineage_id_prop, geff_md.track_node_props, geff_graph
    )
    time_prop = _identify_time_prop(time_prop, geff_md, geff_graph)

    # EVERYTHING BELOW IS NOT DEBUGGED YET

    cell_x_prop, cell_y_prop, cell_z_prop = _identify_space_props(
        cell_x_prop, cell_y_prop, cell_z_prop, geff_md, geff_graph
    )

    # Extract and dispatch metadata.
    # TODO: get first time axis as ref time prop if not given.
    # Generic md should probably be set later, once we have identify time and space properties.
    generic_md = _build_generic_metadata(geff_file, geff_md, time_prop)
    props_md = _build_props_metadata(geff_md)

    # Split the graph into lineages
    lineages = _split_graph_into_lineages(geff_graph, lineage_ID_key=lineage_id_prop)

    # print(f"Number of lineages: {len(lineages)}")
    if lineage_id_prop is None:
        _set_lineage_id(lineages)
        lineage_id_prop = "lineage_ID"

    # Rename properties to match pycellin conventions
    _normalize_properties_data(
        lineages,
        lineage_id_prop,
        cell_x_prop,
        cell_y_prop,
        cell_z_prop,
        time_prop,
        cell_id_prop,
    )
    _normalize_properties_metadata(
        props_md, cell_x_prop, cell_y_prop, cell_z_prop, generic_md["space_unit"]
    )

    # Create the model
    model = Model(
        model_metadata=generic_md,
        props_metadata=PropsMetadata(props=props_md),
        data=Data({lin.graph["lineage_ID"]: lin for lin in lineages}),
    )
    check_fusions(model)  # pycellin DOES NOT support fusion events

    return model


if __name__ == "__main__":
    geff_file = "/media/lxenard/data/Janelia_Cell_Trackathon/test_pycellin_geff/pycellin_to_geff.geff"
    # geff_file = "E:/Janelia_Cell_Trackathon/reader_test_graph.geff"
    # geff_file = "/media/lxenard/data/Janelia_Cell_Trackathon/mouse-20250719.zarr/tracks"
    # geff_file = "/media/lxenard/data/Janelia_Cell_Trackathon/test_pycellin_geff/test.zarr"
    # geff_file = (
    #     "/media/lxenard/data/Janelia_Cell_Trackathon/test_pycellin_geff/pycellin_to_geff.geff"
    # )
    # geff_file = "E:/Janelia_Cell_Trackathon/test_pycellin_geff/pycellin_to_geff.geff"
    # geff_file = "/media/lxenard/data/Janelia_Cell_Trackathon/test_trackmate_to_geff/FakeTracks.geff"
    # geff_file = "E:/Janelia_Cell_Trackathon/test_trackmate_to_geff/FakeTracks.geff"

    # Yohsuke's file for geffception
    # geff_file = "/media/lxenard/data/Janelia_Cell_Trackathon/cell_segmentation.zarr/tree.geff"
    # geff_file = "E:/Janelia_Cell_Trackathon/cell_segmentation.zarr/tree.geff"
    # geff_file = "/media/lxenard/data/Janelia_Cell_Trackathon/cell_segmentation.zarr/tree.geff/linage_tree.geff"
    # geff_file = "E:/Janelia_Cell_Trackathon/cell_segmentation.zarr/tree.geff/linage_tree.geff"

    import plotly.io as pio

    # Plotly: set the default renderer to browser so I can visualize plots
    pio.renderers.default = "browser"

    print(geff_file)
    model = load_GEFF(
        geff_file,
        time_prop="FRAME",
    )
    # print(model)
    # print("props_dict", model.props_metadata.props)
    # for k in model.props_metadata.props.keys():
    #     print(f"{k}")
    lineages = model.get_cell_lineages()
    # print(f"Number of lineages: {len(lineages)}")
    # for lin in lineages:
    #     print(lin)
    lin0 = lineages[0]
    # lin7 = model.get_cell_lineage_from_ID(7)
    # lin7.plot(
    #     node_hover_props=[
    #         "cell_ID",
    #         "lineage_ID",
    #         "frame",
    #         "cell_x",
    #         "cell_y",
    #         "track_id",
    #         "seg_id",
    #         "tree_id",
    #     ]
    # )
    # print(lin0.nodes(data=True))
    # for node in lin0.nodes(data=True):
    #     print(node)
    #     break
    # lin0.plot()

    # cell_id_key
    # lineage_id_key
    # time_key
    # cell_x_key
    # cell_y_key
    # cell_z_key

    # geff_graph, geff_md = geff.read_nx(geff_file, validate=True)
    # print(geff_graph)
    # # Check how many weakly connected components there are.
    # print(
    #     f"Number of weakly connected components: {len(list(nx.weakly_connected_components(geff_graph)))}"
    # )
    # for k, v in geff_graph.graph.items():
    #     print(f"{k}: {v}")
    # # print(graph.graph["axes"][0].unit)

    # if geff_md.directed:
    #     print("The graph is directed.")

    # metadata = {}  # type: dict[str, Any]
    # metadata["name"] = Path(geff_file).stem
    # metadata["file_location"] = geff_file
    # metadata["provenance"] = "geff"
    # metadata["date"] = str(datetime.now())
    # # metadata["space_unit"] =
    # # metadata["time_unit"] =
    # metadata["pycellin_version"] = version("pycellin")
    # metadata["geff_version"] = geff_md.geff_version
    # for md in geff_md:
    #     print(md)
